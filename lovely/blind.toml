[manifest]
version = "1.0.0"
dump_lua = true
priority = -10

### Blind API

## Set debuffed_by_blind, use it for Matador behavior
## Blind:debuff_card()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = 'card:set_debuff(true)'
position = 'after'
payload = "if card.debuff then card.debuffed_by_blind = true end"
match_indent = true
[[patches]]
[patches.regex]
target = 'blind.lua'
pattern = 'card:set_debuff\(true\); return end'
position = 'at'
payload = """
card:set_debuff(true); if card.debuff then card.debuffed_by_blind = true end; return end"""

## Card:set_debuff()
[[patches]]
[patches.regex]
target = 'card.lua'
pattern = '''
self\.debuff = should_debuff
(?<indent>[\t ]*)end
'''
position = 'after'
payload = """if not self.debuff then self.debuffed_by_blind = false end

"""
line_prepend = '$indent'

## Blind functions

# Blind:set_blind()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "G.GAME.last_blind = G.GAME.last_blind or {}"
position = 'before'
match_indent = true
payload = '''
local obj = self.config.blind
self.children.animatedSprite.atlas = G.ANIMATION_ATLAS[obj.atlas] or G.ANIMATION_ATLAS['blind_chips']'''

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "if self.name == 'The Eye' and not reset then"
position = 'at'
payload = '''
if blind then
    self.in_blind = true
end
local obj = self.config.blind
if not reset and obj.set_blind and type(obj.set_blind) == 'function' then
    obj:set_blind()
elseif self.name == 'The Eye' and not reset then'''
match_indent = true

# Blind:disable()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "if self.name == 'The Water' then"
position = 'before'
match_indent = true
payload = '''
local obj = self.config.blind
if obj.disable and type(obj.disable) == 'function' then
    obj:disable()
end'''

# Blind:defeat()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "if self.name == 'The Manacle' and not self.disabled then"
position = 'before'
match_indent = true
payload = '''
local obj = self.config.blind
if obj.defeat and type(obj.defeat) == 'function' then
    obj:defeat()
end'''

# Blind:debuff_card()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "if self.debuff and not self.disabled and card.area ~= G.jokers then"
position = 'before'
match_indent = true
payload = '''
local obj = self.config.blind
if not self.disabled and obj.recalc_debuff and type(obj.recalc_debuff) == 'function' then
    if obj:recalc_debuff(card, from_blind) then
        card:set_debuff(true)
        if card.debuff then card.debuffed_by_blind = true end
    else
        card:set_debuff(false)
    end
    return
elseif not self.disabled and obj.debuff_card and type(obj.debuff_card) == 'function' then
    sendWarnMessage(("Blind object %s has debuff_card function, recalc_debuff is preferred"):format(obj.key), obj.set)
    if obj:debuff_card(card, from_blind) then
        card:set_debuff(true)
        if card.debuff then card.debuffed_by_blind = true end
    else
        card:set_debuff(false)
    end
    return
end'''

# Blind:stay_flipped()

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "function Blind:stay_flipped(area, card)"
position = 'at'
match_indent = true
payload = '''function Blind:stay_flipped(area, card, from_area)'''

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "if area == G.hand then"
position = 'before'
match_indent = true
payload = '''
local obj = self.config.blind
if obj.stay_flipped and type(obj.stay_flipped) == 'function' then
    return obj:stay_flipped(area, card, from_area)
end'''


[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = "local stay_flipped = G.GAME and G.GAME.blind and G.GAME.blind:stay_flipped(self, card)"
position = 'at'
match_indent = true
payload = '''local stay_flipped = G.GAME and G.GAME.blind and G.GAME.blind:stay_flipped(self, card, area)'''

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = "local stay_flipped = G.GAME and G.GAME.blind and G.GAME.blind:stay_flipped(to, card)"
position = 'at'
match_indent = true
payload = '''local stay_flipped = G.GAME and G.GAME.blind and G.GAME.blind:stay_flipped(to, card, from)'''

# Blind:drawn_to_hand()
[[patches]]
[patches.regex]
target = 'blind.lua'
pattern = "(?<indent>[\t ]*)if self.name == 'Cerulean Bell' then\n"
position = 'before'
line_prepend = '$indent'
payload = '''
local obj = self.config.blind
if obj.drawn_to_hand and type(obj.drawn_to_hand) == 'function' then
    obj:drawn_to_hand()
end
'''

# Blind:debuff_hand()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "if self.debuff then"
position = 'before'
match_indent = true
payload = '''
local obj = self.config.blind
if obj.debuff_hand and type(obj.debuff_hand) == 'function' then
    return obj:debuff_hand(cards, hand, handname, check)
end'''

# Blind:modify_hand()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "if self.disabled then return mult, hand_chips, false end"
position = 'after'
match_indent = true
payload = '''
local obj = self.config.blind
if obj.modify_hand and type(obj.modify_hand) == 'function' then
    return obj:modify_hand(cards, poker_hands, text, mult, hand_chips)
end'''

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "function Blind:modify_hand(cards, poker_hands, text, mult, hand_chips)"
position = 'at'
match_indent = true
payload = '''function Blind:modify_hand(cards, poker_hands, text, mult, hand_chips, scoring_hand)'''

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = "mult, hand_chips, modded = G.GAME.blind:modify_hand(G.play.cards, poker_hands, text, mult, hand_chips)"
position = 'at'
match_indent = true
payload = '''mult, hand_chips, modded = G.GAME.blind:modify_hand(G.play.cards, poker_hands, text, mult, hand_chips, scoring_hand)'''

# Blind:press_play()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = 'if self.name == "The Hook" then'
position = 'before'
match_indent = true
payload = '''
local obj = self.config.blind
if obj.press_play and type(obj.press_play) == 'function' then
    return obj:press_play()
end'''

# Blind:get_loc_debuff_text()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = 'function Blind:get_loc_debuff_text()'
position = 'after'
match_indent = true
payload = '''
    local obj = self.config.blind
    if obj.get_loc_debuff_text and type(obj.get_loc_debuff_text) == 'function' then
        return obj:get_loc_debuff_text()
    end'''

# Blind:set_text()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = "local loc_target = localize{type = 'raw_descriptions', key = self.config.blind.key, set = 'Blind', vars = loc_vars or self.config.blind.vars}"
position = 'at'
match_indent = true
payload = '''
local target = {type = 'raw_descriptions', key = self.config.blind.key, set = 'Blind', vars = loc_vars or self.config.blind.vars}
local obj = self.config.blind
if obj.loc_vars and type(obj.loc_vars) == 'function' then
    local res = obj:loc_vars() or {}
    target.vars = res.vars or target.vars
    target.key = res.key or target.key
end
local loc_target = localize(target)'''

# Blind:load()
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = 'if G.P_BLINDS[blindTable.config_blind] then'
position = 'after'
match_indent = true
payload = '''
if self.config.blind.atlas then
    self.children.animatedSprite.atlas = G.ANIMATION_ATLAS[self.config.blind.atlas]
end'''


# create_UIBox_blind_choice()
# create_UIBox_round_scores_row()
[[patches]]
[patches.regex]
target = 'functions/UI_definitions.lua'
pattern = "(?<indent>[\t ]*)blind_choice.animation = AnimatedSprite\\(0,0, 1.4, 1.4, (?<atlas>G.ANIMATION_ATLAS\\['blind_chips'\\]),  blind_choice.config.pos\\)"
position = 'at'
root_capture = 'atlas'
payload = "G.ANIMATION_ATLAS[blind_choice.config.atlas] or G.ANIMATION_ATLAS['blind_chips']"

# create_UIBox_your_collection_blinds()
[[patches]]
[patches.regex]
target = 'functions/UI_definitions.lua'
pattern = "(?<indent>[\t ]*)local temp_blind = AnimatedSprite\\(0,0,1.3,1.3, G.ANIMATION_ATLAS\\['blind_chips'\\], discovered and v.pos or G.b_undiscovered.pos\\)"
position = 'at'
payload = '''

local s = 1.3
if math.ceil(#blind_tab/6) > 6 then
    s = s * 6/math.ceil(#blind_tab/6)
end
local temp_blind = AnimatedSprite(0,0,s,s, G.ANIMATION_ATLAS[discovered and v.atlas or 'blind_chips'], discovered and v.pos or G.b_undiscovered.pos)'''
line_prepend = '$indent'

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = 'blind_matrix[math.ceil((k-1)/5+0.001)][1+((k-1)%5)] = {n=G.UIT.C, config={align = "cm", padding = 0.1}, nodes={'
match_indent = true
position = 'at'
payload = '''
local blinds_per_row = math.ceil(#blind_tab / 6)
local row = math.ceil((k - 1) / blinds_per_row + 0.001)
table.insert(blind_matrix[row], {
    n = G.UIT.C,
    config = { align = "cm", padding = 0.1 },
    nodes = {
        ((k - blinds_per_row) % (2 * blinds_per_row) == 1) and { n = G.UIT.B, config = { h = 0.2, w = 0.5 } } or nil,
        { n = G.UIT.O, config = { object = temp_blind, focus_with_object = true } },
        ((k - blinds_per_row) % (2 * blinds_per_row) == 0) and { n = G.UIT.B, config = { h = 0.2, w = 0.5 } } or nil,
    }
})'''

[[patches]]
[patches.regex]
target = 'functions/UI_definitions.lua'
pattern = '[\t ]*\(k==6 or k ==16 or k == 26\) and \{n=G.UIT.B, config=\{h=0.2,w=0.5\}\} or nil,\n[\t ]*\{n=G.UIT.O, config=\{object = temp_blind, focus_with_object = true\}\},\n[\t ]*\(k==5 or k ==15 or k == 25\) and \{n=G.UIT.B, config=\{h=0.2,w=0.5\}\} or nil,\n[\t ]*\}\}'
position = 'at'
payload = ''

[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = 'table.sort(blind_tab, function (a, b) return a.order < b.order end)'
match_indent = true
position = 'at'
payload = '''
table.sort(blind_tab, function(a, b) return a.order + (a.boss and a.boss.showdown and 1000 or 0) < b.order + (b.boss and b.boss.showdown and 1000 or 0) end)'''

# add_round_eval_row()
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = "local blind_sprite = AnimatedSprite(0, 0, 1.2,1.2, G.ANIMATION_ATLAS['blind_chips'], copy_table(G.GAME.blind.pos))"
match_indent = true
position = 'at'
payload = '''
local obj = G.GAME.blind.config.blind
local blind_sprite = AnimatedSprite(0, 0, 1.2, 1.2, G.ANIMATION_ATLAS[obj.atlas] or G.ANIMATION_ATLAS['blind_chips'], copy_table(G.GAME.blind.pos))'''

# display blind descriptions in info_queue
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "elseif _c.set == 'Tarot' then"
position = "before"
match_indent = true
payload = '''elseif _c.set == 'Blind' then
    local coll_loc_vars = (_c.collection_loc_vars and type(_c.collection_loc_vars) == 'function' and _c:collection_loc_vars()) or {}
    loc_vars = coll_loc_vars.vars or _c.vars
    localize{type = 'descriptions', key = coll_loc_vars.key or _c.key, set = _c.set, nodes = desc_nodes, vars = loc_vars}
'''

# create_UIBox_blind_choice()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "local loc_target = localize{type = 'raw_descriptions', key = blind_choice.config.key, set = 'Blind', vars = {localize(G.GAME.current_round.most_played_poker_hand, 'poker_hands')}}"
match_indent = true
position = 'at'
payload = '''
local target = {type = 'raw_descriptions', key = blind_choice.config.key, set = 'Blind', vars = {}}
if blind_choice.config.name == 'The Ox' then
       target.vars = {localize(G.GAME.current_round.most_played_poker_hand, 'poker_hands')}
end
local obj = blind_choice.config
if obj.loc_vars and _G['type'](obj.loc_vars) == 'function' then
    local res = obj:loc_vars() or {}
    target.vars = res.vars or target.vars
    target.key = res.key or target.key
end
local loc_target = localize(target)'''

# create_UIBox_blind_popup()
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = '''local loc_target = localize{type = 'raw_descriptions', key = blind.key, set = 'Blind', vars = vars or blind.vars}'''
match_indent = true
position = 'at'
payload = '''
local target = {type = 'raw_descriptions', key = blind.key, set = 'Blind', vars = vars or blind.vars}
if blind.collection_loc_vars and type(blind.collection_loc_vars) == 'function' then
    local res = blind:collection_loc_vars() or {}
    target.vars = res.vars or target.vars
    target.key = res.key or target.key
end
local loc_target = localize(target)'''

# G.UIDEF.challenge_description_tab
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "local temp_blind = AnimatedSprite(0,0,1,1, G.ANIMATION_ATLAS['blind_chips'], v.pos)"
position = 'at'
match_indent = true
payload = "local temp_blind = AnimatedSprite(0,0,1,1, G.ANIMATION_ATLAS[v.atlas or ''] or G.ANIMATION_ATLAS['blind_chips'], v.pos)"

## elseif-ify some if chains
[[patches]]
[patches.regex]
target = 'blind.lua'
pattern = "end\n(?<indent>[\t ]*)if self.name == ['\"](?<ability>.*?)['\"]"
position = 'at'
payload = "elseif self.name == '$ability'"

# revert the change for The Pillar
[[patches]]
[patches.regex]
target = 'blind.lua'
pattern = "(?<indent>[\t ]*)elseif self.name == 'The Pillar' and card.ability.played_this_ante then"
position = 'at'
line_prepend = '$indent'
payload = '''end
if self.name == 'The Pillar' and card.ability.played_this_ante then'''

# revert the change for The Eye in debuff_hand
[[patches]]
[patches.regex]
target = 'blind.lua'
pattern = "(?<indent>[\t ]*)elseif self.name == 'The Eye' then"
position = 'at'
line_prepend = '$indent'
payload = '''end
if self.name == 'The Eye' then'''

# revert the change for The Arm in debuff_hand
[[patches]]
[patches.regex]
target = 'blind.lua'
pattern = "(?<indent>[\t ]*)elseif self.name == 'The Arm' then"
position = 'at'
line_prepend = '$indent'
payload = '''end
if self.name == 'The Arm' then'''

# revert the change for Crimson Heart in debuff_card
[[patches]]
[patches.regex]
target = 'blind.lua'
pattern = '''(?<indent>[\t ]*)elseif self\.name == 'Crimson Heart' and not self\.disabled'''
position = 'at'
line_prepend = '$indent'
payload = '''end
if self.name == 'Crimson Heart' and not self.disabled'''





#
# Patches to enable extra blind support
#

# Game:start_run()
[[patches]]
[patches.pattern]
target = "game.lua"
match_indent = true
pattern = "self.GAME = saveTable and saveTable.GAME or self:init_game_object()"
position = "after"
payload = '''
self.GAME.extra_blinds = self.GAME.extra_blinds or {}
'''

# save_run()
[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''G.culled_table =  recursive_table_cull{'''
position = "before"
payload = '''local extra_blinds = {}
if G.GAME.extra_blinds then
    for i, v in ipairs(G.GAME.extra_blinds) do
        if (type(v) == "table") and v.is and v:is(Blind) then
            local extra_blind_ser = v:save()
            if extra_blind_ser then extra_blinds[i] = extra_blind_ser end
        end
    end
end
if not next(extra_blinds) then
    extra_blinds = nil
end'''
match_indent = true
times = 1

# save_run()
[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''BLIND = G.GAME.blind:save(),'''
position = "after"
payload = '''EXTRA_BLINDS = extra_blinds,'''
match_indent = true
times = 1

# Game:start_run()
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''G.GAME.blind:load(saveTable.BLIND)'''
position = "after"
payload = '''
if saveTable.EXTRA_BLINDS then
    self.GAME.extra_blinds = {}
    for i, v in ipairs(saveTable.EXTRA_BLINDS) do
        local blind_source = nil
        if v.extra_blind then
            if G.GAME.blind.in_blind and G.P_BLINDS[v.extra_blind] then
                blind_source = G.GAME.blind
            elseif v.extra_blind == true then
                blind_source = {}
            else
                for _, card in ipairs(G.I.CARD) do
                    if card.unique_val == v.extra_blind then
                        blind_source = card
                        break
                    end
                end
            end
        end

        if blind_source then
            local new_extra_blind = SMODS.init_extra_blind(0, 0, 0, 0, blind_source)
            new_extra_blind:load(v)
            if blind_source == G.GAME.blind then
                blind_source.blind_type = new_extra_blind.config.blind
            elseif blind_source.ability and type(blind_source.ability) == 'table' then
                blind_source.ability.blind_type = new_extra_blind.config.blind
            end
            self.GAME.extra_blinds[#self.GAME.extra_blinds+1] = new_extra_blind
        end
    end
end'''
match_indent = true
times = 1

# G.FUNCS.evaluate_play()
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''mult, hand_chips, modded = G.GAME.blind:modify_hand(G.play.cards, poker_hands, text, mult, hand_chips, scoring_hand)
mult, hand_chips = mod_mult(mult), mod_chips(hand_chips)
if modded then update_hand_text({sound = 'chips2', modded = modded}, {chips = hand_chips, mult = mult}) end'''
position = "after"
payload = '''for _, v in ipairs(G.GAME.extra_blinds) do
    if G.GAME.blind.config.blind ~= v.config.blind then
        mult, hand_chips, modded = v:modify_hand(G.play.cards, poker_hands, text, mult, hand_chips, scoring_hand)
        mult, hand_chips = mod_mult(mult), mod_chips(hand_chips)
        if modded then update_hand_text({sound = 'chips2', modded = modded}, {chips = hand_chips, mult = mult}) end
    end
end'''
match_indent = true
times = 1

# Game:update(dt)
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if G.GAME.blind and G.boss_throw_hand and self.STATE == self.STATES.SELECTING_HAND then'''
position = "at"
payload = '''local blind_strings = {}
if self.STATE == self.STATES.SELECTING_HAND then
    if G.GAME.blind and G.boss_throw_hand then blind_strings[#blind_strings+1] = SMODS.debuff_text or G.GAME.blind:get_loc_debuff_text() end
    for _, v in ipairs(G.GAME.extra_blinds) do
        local debuff_text = v:get_loc_debuff_text()
        if v.extra_boss_throw_hand and debuff_text then blind_strings[#blind_strings+1] = debuff_text end
    end

    if #blind_strings > 1 and blind_strings[1] == '' then table.remove(blind_strings, 1) end
end
if #blind_strings > 0 then
    local dyna_strings = {}
    for _, v in ipairs(blind_strings) do
        dyna_strings[#dyna_strings+1] = { string = v, colour = G.C.WHITE }
    end'''
match_indent = true
times = 1

# Game:update(dt)
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''G.boss_throw_hand = nil'''
position = "after"
payload = '''if G.GAME.extra_blinds and G.GAME.extra_blinds[1] ~= [["]].."MANUAL_REPLACE"..[["]] then
    for _, v in ipairs(G.GAME.extra_blinds) do
        v.extra_boss_throw_hand = nil
    end
end'''
match_indent = true
times = 1

# Game:update(dt)
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''{n=G.UIT.O, config={func = "update_blind_debuff_text", object = DynaText({scale = 0.6, string = SMODS.debuff_text or G.GAME.blind:get_loc_debuff_text(), maxw = 9, colours = {G.C.WHITE},float = true, shadow = true, silent = true, pop_in = 0, pop_in_rate = 6})}},'''
position = "at"
payload = '''{n=G.UIT.O, config={func = "update_blind_debuff_text", object = DynaText({scale = 0.6, string = dyna_strings, maxw = 9, colours = {G.C.WHITE},float = true, shadow = true, silent = true, pop_in = 0, pop_in_rate = 6, pop_delay = 1, min_cycle_time = 3})}},'''
match_indent = true
times = 1

# G.FUNCS.play_cards_from_highlighted
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''   delay(0.4)
end'''
position = "after"
payload = '''
for _, v in ipairs(G.GAME.extra_blinds) do
    if v:press_play() then
        G.E_MANAGER:add_event(Event({
            trigger = 'immediate',
            func = (function()
                -- SMODS.juice_up_blind()
                G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.06*G.SETTINGS.GAMESPEED, blockable = false, blocking = false, func = function()
                    play_sound('tarot2', 0.76, 0.4);return true end}))
                play_sound('tarot2', 1, 0.4)
                return true
            end)
        }))
    end
end'''
match_indent = true
times = 1

# CardArea:parse_highlighted()
[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = '''if G.GAME.blind and G.GAME.blind:debuff_hand(self.highlighted, poker_hands, text, true) then
    G.boss_throw_hand = true
else'''
position = "at"
payload = '''if G.GAME.blind then
    local debuff, extra_only = G.GAME.blind:debuff_hand(self.highlighted, poker_hands, text, true)
    G.boss_throw_hand = (debuff and not extra_only)'''
match_indent = true
times = 1





#
# For the purposes of extra blinds, centralizes Blind typing with Blind:get_type() instead of Blind.boss
#

# end_round()
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if G.GAME.blind:get_type() == 'Boss' then
    local _handname, _played, _order = 'High Card', -1, 100'''
position = "at"
payload = '''
if true then
    local _handname, _played, _order = 'High Card', -1, 100'''
match_indent = true
times = 1

[[patches]]
[patches.regex]
target = 'functions/state_events.lua'
pattern = 'G\.GAME\.blind\.boss'
position = 'at'
payload = "G.GAME.blind:get_type() == 'Boss'"

[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = "(G.GAME.blind and G.GAME.blind.boss and 'music5') or"
position = 'at'
payload = "(G.GAME.blind and G.GAME.blind:get_type() == 'Boss' and 'music5') or"
match_indent = true

[[patches]]
[patches.regex]
target = 'card.lua'
pattern = 'not context\.blind\.boss'
position = 'at'
payload = "G.GAME.blind:get_type() ~= 'Boss'"

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''if self.boss and G.GAME.chips - G.GAME.blind.chips >= 0 then'''
position = 'at'
payload = '''if self:get_type() == 'Boss' and G.GAME.chips - G.GAME.blind.chips >= 0 then'''
match_indent = true

[[patches]]
[patches.regex]
target = 'card.lua'
pattern = 'context\.blind\.boss'
position = 'at'
payload = "G.GAME.blind:get_type() == 'Boss'"

# Back:trigger_effect(args)
[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = '''if self.disabled then self.block_play = nil; return true end'''
position = "at"
payload = '''if self.disabled or self.main_blind_disabled then self.block_play = nil; return true end'''
match_indent = true
times = 1

# create_UIBox_blind_choice()
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''{n=G.UIT.R, config={align = "cm", r = 0.1, outline = 1, outline_colour = blind_col, colour = darken(blind_col, 0.3), minw = 2.9, emboss = 0.1, padding = 0.07, line_emboss = 1}, nodes={'''
position = "at"
payload = '''{n=G.UIT.R, config={align = "cm", r = 0.1, outline = 1, outline_colour = blind_col, colour = blind_choice.config.special_colour or darken(blind_col, 0.3), minw = 2.9, emboss = 0.1, padding = 0.07, line_emboss = 1}, nodes={'''
match_indent = true
times = 1

# create_UIBox_blind_choice()
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''G.blind_select_opts.boss = G.GAME.round_resets.blind_states['Boss'] ~= 'Hide' and UIBox{definition = {n=G.UIT.ROOT, config={align = "cm", colour = G.C.CLEAR}, nodes={UIBox_dyn_container({create_UIBox_blind_choice('Boss')},false,get_blind_main_colour('Boss'), mix_colours(G.C.BLACK, get_blind_main_colour('Boss'), 0.8))}}, config = {align="bmi", offset = {x=0,y=0}}} or nil'''
position = "at"
payload = '''G.blind_select_opts.boss = G.GAME.round_resets.blind_states['Boss'] ~= 'Hide' and UIBox{
    definition = {
      n=G.UIT.ROOT,
      config={align = "cm", colour = G.C.CLEAR},
      nodes={
        UIBox_dyn_container(
          {create_UIBox_blind_choice('Boss')},
          false,
          get_blind_main_colour('Boss'),
          G.P_BLINDS[G.GAME.round_resets.blind_choices['Boss']].special_colour or mix_colours(G.C.BLACK, get_blind_main_colour('Boss'),0.8)
        )
      }
    },
    config = {align="bmi", offset = {x=0,y=0}}} or nil'''
match_indent = true
times = 1